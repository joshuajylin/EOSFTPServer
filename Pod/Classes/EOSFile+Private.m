/*******************************************************************************
 * Copyright (c) 2012, Jean-David Gadina - www.xs-labs.com
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id$ */

/*!
 * @file            ...
 * @author          Jean-David Gadina - www.xs-labs.com
 * @copyright       (c) 2012, XS-Labs
 * @abstract        ...
 */

#import "EOSFile+Private.h"
#import <sys/stat.h>

@implementation EOSFile( Private )

- ( BOOL )getFileInformations
{
    int            status;
    struct stat    stats;
    NSUInteger     uid;
    NSUInteger     gid;
    NSUInteger     u;
    NSUInteger     g;
    NSUInteger     o;
    NSUInteger     i;
    NSUInteger     perms;
    NSError      * e;
    NSDictionary * attributes;
    NSString     * humanPerms;
    
    uid         = getuid();
    gid         = getgid();
    e           = nil;
    attributes  = [ [ NSFileManager defaultManager ] attributesOfItemAtPath: _path error: &e ];
    
    if( e != nil )
    {
        return NO;
    }
    
    /* File flags */
    
    status = stat( ( const char * )[ _path cStringUsingEncoding: NSUTF8StringEncoding ], &stats );
    
    if( status != 0 )
    {
        return NO;
    }
    
    if( stats.st_flags & SF_ARCHIVED  ) { _flags |= EOSFileFlagsArchived; }
    if( stats.st_flags & UF_HIDDEN    ) { _flags |= EOSFileFlagsHidden; }
    if( stats.st_flags & UF_NODUMP    ) { _flags |= EOSFileFlagsNoDump; }
    if( stats.st_flags & UF_OPAQUE    ) { _flags |= EOSFileFlagsOpaque; }
    if( stats.st_flags & SF_APPEND    ) { _flags |= EOSFileFlagsSystemAppendOnly; }
    if( stats.st_flags & SF_IMMUTABLE ) { _flags |= EOSFileFlagsSystemImmutable; }
    if( stats.st_flags & UF_APPEND    ) { _flags |= EOSFileFlagsUserAppendOnly; }
    if( stats.st_flags & UF_IMMUTABLE ) { _flags |= EOSFileFlagsUserImmutable; }
    
    /* Name informations */
    
    _name           = [ [ NSString alloc ] initWithString: [ _path lastPathComponent ] ];
    _displayName    = [ [ NSString alloc ] initWithString: [ [ NSFileManager defaultManager ] displayNameAtPath: _path ] ];
    _extension      = [ [ NSString alloc ] initWithString: [ _path pathExtension ] ];
    
    /* File type */
    
    if( [ attributes objectForKey: NSFileType ] == NSFileTypeDirectory        ) { _type = EOSFileTypeDirectory;        }
    else if( [ attributes objectForKey: NSFileType ] == NSFileTypeRegular          ) { _type = EOSFileTypeRegularFile;      }
    else if( [ attributes objectForKey: NSFileType ] == NSFileTypeSymbolicLink     ) { _type = EOSFileTypeSymbolicLink;     }
    else if( [ attributes objectForKey: NSFileType ] == NSFileTypeSocket           ) { _type = EOSFileTypeSocket;           }
    else if( [ attributes objectForKey: NSFileType ] == NSFileTypeCharacterSpecial ) { _type = EOSFileTypeCharacterSpecial; }
    else if( [ attributes objectForKey: NSFileType ] == NSFileTypeBlockSpecial     ) { _type = EOSFileTypeBlockSpecial;     }
    else if( [ attributes objectForKey: NSFileType ] == NSFileTypeUnknown          ) { _type = EOSFileTypeUnknown;          }
    else                                                                             { _type = EOSFileTypeUnknown;          }
    
    /* Standard attributes */
    
    _ownerID            = ( [ attributes objectForKey: NSFileOwnerAccountID        ] == nil ) ? 0                                          : [ [ attributes objectForKey: NSFileOwnerAccountID      ] unsignedIntegerValue ];
    _groupID            = ( [ attributes objectForKey: NSFileGroupOwnerAccountID   ] == nil ) ? 0                                          : [ [ attributes objectForKey: NSFileGroupOwnerAccountID ] unsignedIntegerValue ];
    _owner              = ( [ attributes objectForKey: NSFileOwnerAccountName      ] == nil ) ? [ [ NSString alloc ] initWithString: @"" ] : [ [ attributes objectForKey: NSFileOwnerAccountName    ] copy ];
    _group              = ( [ attributes objectForKey: NSFileGroupOwnerAccountName ] == nil ) ? [ [ NSString alloc ] initWithString: @"" ] : [ [ attributes objectForKey: NSFileOwnerAccountName    ] copy ];
    _immutable          = ( [ attributes objectForKey: NSFileImmutable             ] == nil ) ? NO                                         : [ [ attributes objectForKey: NSFileImmutable           ] boolValue ];
    _appendOnly         = ( [ attributes objectForKey: NSFileAppendOnly            ] == nil ) ? NO                                         : [ [ attributes objectForKey: NSFileAppendOnly          ] boolValue ];
    _busy               = ( [ attributes objectForKey: NSFileBusy                  ] == nil ) ? NO                                         : [ [ attributes objectForKey: NSFileBusy                ] boolValue ];
    _extensionHidden    = ( [ attributes objectForKey: NSFileExtensionHidden       ] == nil ) ? NO                                         : [ [ attributes objectForKey: NSFileExtensionHidden     ] boolValue ];
    _referenceCount     = ( [ attributes objectForKey: NSFileReferenceCount        ] == nil ) ? 0                                          : [ [ attributes objectForKey: NSFileReferenceCount      ] unsignedIntegerValue ];
    _systemNumber       = ( [ attributes objectForKey: NSFileSystemNumber          ] == nil ) ? 0                                          : [ [ attributes objectForKey: NSFileSystemNumber        ] unsignedIntegerValue ];
    _systemFileNumber   = ( [ attributes objectForKey: NSFileSystemFileNumber      ] == nil ) ? 0                                          : [ [ attributes objectForKey: NSFileSystemFileNumber    ] unsignedIntegerValue ];
    _deviceIdentifier   = ( [ attributes objectForKey: NSFileDeviceIdentifier      ] == nil ) ? 0                                          : [ [ attributes objectForKey: NSFileDeviceIdentifier    ] unsignedIntegerValue ];
    _HFSCreatorCode     = ( [ attributes objectForKey: NSFileHFSCreatorCode        ] == nil ) ? 0                                          : [ [ attributes objectForKey: NSFileHFSCreatorCode      ] unsignedIntegerValue ];
    _HFSTypeCode        = ( [ attributes objectForKey: NSFileHFSTypeCode           ] == nil ) ? 0                                          : [ [ attributes objectForKey: NSFileHFSTypeCode         ] unsignedIntegerValue ];
    _creationDate       = ( [ attributes objectForKey: NSFileCreationDate          ] == nil ) ? [ [ NSDate date ] retain ]                 : [ [ attributes objectForKey: NSFileCreationDate        ] retain ];
    _modificationDate   = ( [ attributes objectForKey: NSFileModificationDate      ] == nil ) ? [ [ NSDate date ] retain ]                 : [ [ attributes objectForKey: NSFileModificationDate    ] retain ];
    _bytes              = ( [ attributes objectForKey: NSFileSize                  ] == nil ) ? 0                                          : [ [ attributes objectForKey: NSFileSize                ] unsignedIntegerValue ];
    _permissions        = ( [ attributes objectForKey: NSFilePosixPermissions      ] == nil ) ? 0                                          : [ [ attributes objectForKey: NSFilePosixPermissions    ] unsignedIntegerValue ];
    
    /* File size */
    
    _kiloBytes =       _bytes / 1000;
    _megaBytes =     ( _bytes / 1000 ) / 1000;
    _gigaBytes =   ( ( _bytes / 1000 ) / 1000 ) / 1000;
    _teraBytes = ( ( ( _bytes / 1000 ) / 1000 ) / 1000 ) / 1000;
    
    if( _teraBytes >= 1 )
    {
        _humanReadableSize = [ [ NSString alloc ] initWithFormat: @"%f TB", _teraBytes ];
    }
    else if( _gigaBytes >= 1 )
    {
        _humanReadableSize = [ [ NSString alloc ] initWithFormat: @"%f GB", _gigaBytes ];
    }
    else if( _megaBytes >= 1 )
    {
        _humanReadableSize = [ [ NSString alloc ] initWithFormat: @"%f MB", _megaBytes ];
    }
    else if( _kiloBytes >= 1 )
    {
        _humanReadableSize = [ [ NSString alloc ] initWithFormat: @"%f KB", _kiloBytes ];
    }
    else
    {
        _humanReadableSize = [ [ NSString alloc ] initWithFormat: @"%lu bytes", (unsigned long)_bytes ];
    }
    
    /* File permissions */
    
    u =   _permissions / 64;
    g = ( _permissions - ( 64 * u ) ) / 8;
    o = ( _permissions - ( 64 * u ) ) - ( 8 * g );
    
    _octalPermissions = ( u * 100 ) + ( g * 10 ) + o;
    
    if( _ownerID == uid )
    {
        _readable   = ( u & 4 ) ? YES : NO;
        _writeable  = ( u & 2 ) ? YES : NO;
        _executable = ( u & 1 ) ? YES : NO;
    }
    else if( _groupID == gid )
    {
        _readable   = ( g & 4 ) ? YES : NO;
        _writeable  = ( g & 2 ) ? YES : NO;
        _executable = ( g & 1 ) ? YES : NO;
    }
    else
    {
        _readable   = ( o & 4 ) ? YES : NO;
        _writeable  = ( o & 2 ) ? YES : NO;
        _executable = ( o & 1 ) ? YES : NO;
    }
    
    if( _readable == NO && [ [ NSFileManager defaultManager ] isReadableFileAtPath: _path ] == YES )
    {
        _readable = YES;
    }
    
    if( _writeable == NO && [ [ NSFileManager defaultManager ] isWritableFileAtPath: _path ] == YES )
    {
        _writeable = YES;
    }
    
    if( _executable == NO && [ [ NSFileManager defaultManager ] isExecutableFileAtPath: _path ] == YES )
    {
        _executable = YES;
    }
    
    perms      = _permissions;
    humanPerms = @"";
    
    for( i = 0; i < 3; i++ )
    {
        humanPerms  = [ [ NSString stringWithFormat:
                         @"%@%@%@",
                         ( perms & 4 ) ? @"r" : @"-",
                         ( perms & 2 ) ? @"w" : @"-",
                         ( perms & 1 ) ? @"x" : @"-"
                         ] stringByAppendingString: humanPerms
                       ];
        
        perms = perms >> 3;
    }
    
    _humanReadablePermissions = [ humanPerms copy ];
    
    return YES;
}

@end
