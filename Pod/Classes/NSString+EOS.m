/*******************************************************************************
 * Copyright (c) 2012, Jean-David Gadina - www.xs-labs.com
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id$ */

/*!
 * @file            ...
 * @author          Jean-David Gadina - www.xs-labs.com
 * @copyright       (c) 2012, XS-Labs
 * @abstract        ...
 */

#import "NSString+EOS.h"

#define MD5_S11  7
#define MD5_S12 12
#define MD5_S13 17
#define MD5_S14 22
#define MD5_S21  5
#define MD5_S22  9
#define MD5_S23 14
#define MD5_S24 20
#define MD5_S31  4
#define MD5_S32 11
#define MD5_S33 16
#define MD5_S34 23
#define MD5_S41  6
#define MD5_S42 10
#define MD5_S43 15
#define MD5_S44 21

#define MD5_F( x, y, z )        ( ( ( x ) & ( y ) ) | ( ( ~x ) & ( z ) ) )
#define MD5_G( x, y, z )        ( ( ( x ) & ( z ) ) | ( ( y ) & ( ~z ) ) )
#define MD5_H( x, y, z )        ( ( x ) ^ ( y ) ^ ( z ) )
#define MD5_I( x, y, z )        ( ( y ) ^ ( ( x ) | ( ~z ) ) )

#define MD5_ROTATE_LEFT( x, n ) ( ( ( x ) << ( n ) ) | ( ( x ) >> ( 32 -( n ) ) ) )

#define MD5_FF( a, b, c, d, x, s, ac )                                  \
{                                                                       \
    ( a ) += MD5_F( ( b ), ( c ), ( d ) ) + ( x ) + ( uint32_t )( ac ); \
    ( a )  = MD5_ROTATE_LEFT( ( a ), ( s ) );                           \
    ( a ) += ( b );                                                     \
}

#define MD5_GG( a, b, c, d, x, s, ac )                                  \
{                                                                       \
    ( a ) += MD5_G( ( b ), ( c ), ( d ) ) + ( x ) + ( uint32_t )( ac ); \
    ( a )  = MD5_ROTATE_LEFT( ( a ), ( s ) );                           \
    ( a ) += ( b );                                                     \
}

#define MD5_HH( a, b, c, d, x, s, ac )                                  \
{                                                                       \
    ( a ) += MD5_H( ( b ), ( c ), ( d ) ) + ( x ) + ( uint32_t )( ac ); \
    ( a )  = MD5_ROTATE_LEFT( ( a ), ( s ) );                           \
    ( a ) += ( b );                                                     \
}

#define MD5_II( a, b, c, d, x, s, ac )                                  \
{                                                                       \
    ( a ) += MD5_I( ( b ), ( c ), ( d ) ) + ( x ) + ( uint32_t )( ac ); \
    ( a )  = MD5_ROTATE_LEFT( ( a ), ( s ) );                           \
    ( a ) += ( b );                                                     \
}

typedef unsigned char md5_hash[ 16 ];
typedef char          md5_hex_hash[ 33 ];
typedef struct        md5_context_struct
{
    uint32_t      state[ 4 ];
    uint32_t      count[ 2 ];
    unsigned char buffer[ 64 ];
}
md5_context;

static void md5_hash2hex( md5_hash bin, md5_hex_hash hex );
static void md5_init( md5_context * context );
static void md5_update( md5_context * context, const void * input, unsigned int length );
static void md5_final( unsigned char digest[ 16 ], md5_context * context );
static char __md5_int2hex( char c );
static void __md5_transform(uint32_t state[ 4 ], const unsigned char block[ 64 ] );
static void __md5_encode( unsigned char * output, uint32_t * input, unsigned int length );
static void __md5_decode( uint32_t * output, const unsigned char * input, unsigned int length );

static const char  * __hex           = "0123456789abcdef";
static unsigned char __padding[ 64 ] =
{
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const unsigned int __crc_table[ 256 ] =
{
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x6DDDE4EB, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

@implementation NSString( EOS )

- ( NSString * )URLEncodedString
{
    size_t            i;
    const char      * source;
    unsigned char     currentChar;
    size_t            sourceLength;
    NSMutableString * output;
    
    source       = [ self cStringUsingEncoding: NSUTF8StringEncoding ];
    sourceLength = strlen( ( const char * )source );
    output       = [ NSMutableString string ];
    
    for( i = 0; i < sourceLength; ++i )
    {
        currentChar = ( unsigned char )source[ i ];
        
        if( currentChar == ' ' )
        {
            [ output appendString: @"+" ];
        }
        else if
        (
               currentChar == '.'
            || currentChar == '-'
            || currentChar == '_'
            || currentChar == '~'
            || ( currentChar >= 'a' && currentChar <= 'z' )
            || ( currentChar >= 'A' && currentChar <= 'Z' )
            || ( currentChar >= '0' && currentChar <= '9' )
        )
        {
            [output appendFormat: @"%c", currentChar ];
        }
        else
        {
            [ output appendFormat: @"%%%02X", currentChar ];
        }
    }
    
    return output;
}

- ( NSUInteger )crc32
{
    const char * cString;
    unsigned int i;
    unsigned int c;
    
    c        = 0xFFFFFFFF;
    cString  = [ self cStringUsingEncoding: NSUTF8StringEncoding ];
    
    for( i = 0; i < [ self length ]; i++ )
    {
        c = __crc_table[ ( c ^ ( unsigned int )*( cString ) ) & 0xFF ] ^ ( ( c >> 8 ) & 0x00FFFFFF );
        
        cString++;
    }
    
    return c ^ 0xFFFFFFFF;
}

- ( NSString * )md5Hash
{
    const char * str;
	char         HashStr[ 256 ];
	md5_context  ctx;
	md5_hash     hash;
    NSString   * ret;
    
	str = [ self UTF8String ];
	
    md5_init( &ctx );
    md5_update( &ctx, str, ( unsigned int )( strlen( str ) ) );
    md5_final( hash, &ctx );
    md5_hash2hex( hash, HashStr );
	
    ret = [ NSString stringWithCString: HashStr encoding: NSUTF8StringEncoding ];
    
	return ret;
}

@end

static char __md5_int2hex( char c )
{
	return __hex[ ( c & 0x0F ) ];
}

static void md5_hash2hex( md5_hash bin, md5_hex_hash hex )
{
	unsigned short i;
	
	for( i = 0; i < 16; i++ )
    {
		hex[ i * 2 ]     = __md5_int2hex( ( bin[ i ] >> 4 ) & 0xF );
		hex[ i * 2 + 1 ] = __md5_int2hex( bin[ i ] & 0xF );
	}
    
	hex[ 32 ] = 0;
}

static void md5_init( md5_context * context )
{
    context->count[ 0 ] = 0;
    context->count[ 1 ] = 0;
    
    context->state[ 0 ] = 0x67452301;
    context->state[ 1 ] = 0xEFCDAB89;
    context->state[ 2 ] = 0x98BADCFE;
    context->state[ 3 ] = 0x10325476;
}

static void md5_update( md5_context * context, const void * input, unsigned int length )
{
    unsigned int          i;
    unsigned int          ndx;
    unsigned int          partLen;
    const unsigned char * _input;
    
    _input = ( const unsigned char * )input;
    ndx    = ( unsigned int ) ( ( context->count[ 0 ] >> 3 ) & 0x3F );
    
    if( ( context->count[ 0 ] += ( ( uint32_t )length << 3 ) ) < ( ( uint32_t )length << 3 ) )
    {
        context->count[ 1 ]++;
    }
    
    context->count[ 1 ] += ( ( uint32_t )length >> 29 );
    partLen              = 64 - ndx;
    
    if( length >= partLen )
    {
        memcpy
        (
            ( unsigned char * )&context->buffer[ ndx ],
            ( const unsigned char * )_input,
            partLen
        );
        __md5_transform( context->state, context->buffer );
        
        for( i = partLen; i + 63 < length; i += 64 )
        {
            __md5_transform( context->state, &_input[ i ] );
        }
        
        ndx = 0;
    }
    else
    {
        i = 0;
    }
    
    memcpy
    (
        ( unsigned char * )&context->buffer[ ndx ],
        ( const unsigned char * )&_input[ i ],
        length-i
    );
}

static void md5_final( unsigned char digest[ 16 ], md5_context * context )
{
    unsigned char bits[ 8 ];
    unsigned int  ndx;
    unsigned int  padLen;
    
    __md5_encode( bits, context->count, 8 );
    
    ndx    = ( unsigned int )( ( context->count[ 0 ] >> 3 ) & 0x3F );
    padLen = ( ndx < 56 ) ? ( 56 - ndx ) : ( 120 - ndx );
    
    md5_update( context, __padding, padLen );
    md5_update( context, bits, 8 );
    __md5_encode( digest, context->state, 16 );
    memset( ( unsigned char * )context, 0, sizeof( md5_context ) );
}

static void __md5_transform( uint32_t state[ 4 ], const unsigned char block[ 64 ] )
{
    uint32_t a;
    uint32_t b;
    uint32_t c;
    uint32_t d;
    uint32_t x[ 16 ];
    
    a = state[ 0 ];
    b = state[ 1 ];
    c = state[ 2 ];
    d = state[ 3 ];
    
    __md5_decode( x, block, 64 );
    
    MD5_FF( a, b, c, d, x[  0 ], MD5_S11, 0xD76AA478 );
    MD5_FF( d, a, b, c, x[  1 ], MD5_S12, 0xE8C7B756 );
    MD5_FF( c, d, a, b, x[  2 ], MD5_S13, 0x242070DB );
    MD5_FF( b, c, d, a, x[  3 ], MD5_S14, 0xC1BDCEEE );
    MD5_FF( a, b, c, d, x[  4 ], MD5_S11, 0xF57C0FAF );
    MD5_FF( d, a, b, c, x[  5 ], MD5_S12, 0x4787C62A );
    MD5_FF( c, d, a, b, x[  6 ], MD5_S13, 0xA8304613 );
    MD5_FF( b, c, d, a, x[  7 ], MD5_S14, 0xFD469501 );
    MD5_FF( a, b, c, d, x[  8 ], MD5_S11, 0x698098D8 );
    MD5_FF( d, a, b, c, x[  9 ], MD5_S12, 0x8B44F7AF );
    MD5_FF( c, d, a, b, x[ 10 ], MD5_S13, 0xFFFF5BB1 );
    MD5_FF( b, c, d, a, x[ 11 ], MD5_S14, 0x895CD7BE );
    MD5_FF( a, b, c, d, x[ 12 ], MD5_S11, 0x6B901122 );
    MD5_FF( d, a, b, c, x[ 13 ], MD5_S12, 0xFD987193 );
    MD5_FF( c, d, a, b, x[ 14 ], MD5_S13, 0xA679438E );
    MD5_FF( b, c, d, a, x[ 15 ], MD5_S14, 0x49B40821 );
    
    MD5_GG( a, b, c, d, x[  1 ], MD5_S21, 0xF61E2562 );
    MD5_GG( d, a, b, c, x[  6 ], MD5_S22, 0xC040B340 );
    MD5_GG( c, d, a, b, x[ 11 ], MD5_S23, 0x265E5A51 );
    MD5_GG( b, c, d, a, x[  0 ], MD5_S24, 0xE9B6C7AA );
    MD5_GG( a, b, c, d, x[  5 ], MD5_S21, 0xD62F105D );
    MD5_GG( d, a, b, c, x[ 10 ], MD5_S22, 0x02441453 );
    MD5_GG( c, d, a, b, x[ 15 ], MD5_S23, 0xD8A1E681 );
    MD5_GG( b, c, d, a, x[  4 ], MD5_S24, 0xE7D3FBC8 );
    MD5_GG( a, b, c, d, x[  9 ], MD5_S21, 0x21E1CDE6 );
    MD5_GG( d, a, b, c, x[ 14 ], MD5_S22, 0xC33707D6 );
    MD5_GG( c, d, a, b, x[  3 ], MD5_S23, 0xF4D50D87 );
    MD5_GG( b, c, d, a, x[  8 ], MD5_S24, 0x455A14ED );
    MD5_GG( a, b, c, d, x[ 13 ], MD5_S21, 0xA9E3E905 );
    MD5_GG( d, a, b, c, x[  2 ], MD5_S22, 0xFCEFA3F8 );
    MD5_GG( c, d, a, b, x[  7 ], MD5_S23, 0x676F02D9 );
    MD5_GG( b, c, d, a, x[ 12 ], MD5_S24, 0x8D2A4C8A );
    
    MD5_HH( a, b, c, d, x[  5 ], MD5_S31, 0xFFFA3942 );
    MD5_HH( d, a, b, c, x[  8 ], MD5_S32, 0x8771F681 );
    MD5_HH( c, d, a, b, x[ 11 ], MD5_S33, 0x6D9D6122 );
    MD5_HH( b, c, d, a, x[ 14 ], MD5_S34, 0xFDE5380C );
    MD5_HH( a, b, c, d, x[  1 ], MD5_S31, 0xA4BEEA44 );
    MD5_HH( d, a, b, c, x[  4 ], MD5_S32, 0x4BDECFA9 );
    MD5_HH( c, d, a, b, x[  7 ], MD5_S33, 0xF6BB4B60 );
    MD5_HH( b, c, d, a, x[ 10 ], MD5_S34, 0xBEBFBC70 );
    MD5_HH( a, b, c, d, x[ 13 ], MD5_S31, 0x289B7EC6 );
    MD5_HH( d, a, b, c, x[  0 ], MD5_S32, 0xEAA127FA );
    MD5_HH( c, d, a, b, x[  3 ], MD5_S33, 0xD4EF3085 );
    MD5_HH( b, c, d, a, x[  6 ], MD5_S34, 0x04881d05 );
    MD5_HH( a, b, c, d, x[  9 ], MD5_S31, 0xD9D4D039 );
    MD5_HH( d, a, b, c, x[ 12 ], MD5_S32, 0xE6DB99E5 );
    MD5_HH( c, d, a, b, x[ 15 ], MD5_S33, 0x1FA27CF8 );
    MD5_HH( b, c, d, a, x[  2 ], MD5_S34, 0xC4AC5665 );
    
    MD5_II( a, b, c, d, x[  0 ], MD5_S41, 0xF4292244 );
    MD5_II( d, a, b, c, x[  7 ], MD5_S42, 0x432AFF97 );
    MD5_II( c, d, a, b, x[ 14 ], MD5_S43, 0xAB9423A7 );
    MD5_II( b, c, d, a, x[  5 ], MD5_S44, 0xFC93A039 );
    MD5_II( a, b, c, d, x[ 12 ], MD5_S41, 0x655B59C3 );
    MD5_II( d, a, b, c, x[  3 ], MD5_S42, 0x8F0CCC92 );
    MD5_II( c, d, a, b, x[ 10 ], MD5_S43, 0xFFEFF47D );
    MD5_II( b, c, d, a, x[  1 ], MD5_S44, 0x85845DD1 );
    MD5_II( a, b, c, d, x[  8 ], MD5_S41, 0x6FA87E4F );
    MD5_II( d, a, b, c, x[ 15 ], MD5_S42, 0xFE2CE6E0 );
    MD5_II( c, d, a, b, x[  6 ], MD5_S43, 0xA3014314 );
    MD5_II( b, c, d, a, x[ 13 ], MD5_S44, 0x4E0811A1 );
    MD5_II( a, b, c, d, x[  4 ], MD5_S41, 0xF7537E82 );
    MD5_II( d, a, b, c, x[ 11 ], MD5_S42, 0xBD3AF235 );
    MD5_II( c, d, a, b, x[  2 ], MD5_S43, 0x2AD7D2BB );
    MD5_II( b, c, d, a, x[  9 ], MD5_S44, 0xEB86D391 );
    
    state[ 0 ] += a;
    state[ 1 ] += b;
    state[ 2 ] += c;
    state[ 3 ] += d;
    
    memset( ( unsigned char * )x, 0, sizeof( x ) );
}

static void __md5_encode( unsigned char * output, uint32_t * input, unsigned int length )
{
    unsigned int i;
    unsigned int j;
    
    for( i = 0, j = 0; j < length; i++, j += 4 )
    {
        output[ j ]     = ( unsigned char )(   input[ i ]         & 0xFF );
        output[ j + 1 ] = ( unsigned char )( ( input[ i ] >>  8 ) & 0xFF );
        output[ j + 2 ] = ( unsigned char )( ( input[ i ] >> 16 ) & 0xFF );
        output[ j + 3 ] = ( unsigned char )( ( input[ i ] >> 24 ) & 0xFF );
    }
}

static void __md5_decode( uint32_t * output, const unsigned char * input, unsigned int length )
{
    unsigned int i;
    unsigned int j;
    
    for( i = 0, j = 0; j < length; i++, j += 4 )
    {
        output[i] =   ( ( uint32_t )input[ j ] )
                  | ( ( ( uint32_t )input[ j + 1 ] ) <<  8 )
                  | ( ( ( uint32_t )input[ j + 2 ] ) << 16 )
                  | ( ( ( uint32_t )input[ j + 3 ] ) << 24 );
    }
}
